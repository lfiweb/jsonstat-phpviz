

body {
    font: 1rem "Noto Sans", sans-serif;
}

/** highlight only with css ! */
.lastDimSize2 thead tr:not(:first-of-type, :last-of-type) th:nth-child(2 of :not(:empty)),
.lastDimSize2 :where(thead tr:last-of-type, tbody tr) *:nth-child(9 of :not([scope^=row], [class^="rowdim"])) {
    color: red;
}

/* find the first th element with scope=colgroup of the row which is a previous sibling of the last row */
tr:has(+ tr:last-of-type) th:nth-child(1 of [scope=colgroup]) {
    background-color: coral;
}


/** collapse confidence intervals (columns) */
/*.numRowDims0.lastDimSize2 thead tr:last-of-type th:nth-of-type(2n),
.numRowDims1.lastDimSize2 thead tr:last-of-type th:nth-of-type(2n + 3),
.numRowDims2.lastDimSize2 thead tr:last-of-type th:nth-of-type(2n + 4),
.numRowDims3.lastDimSize2 thead tr:last-of-type th:nth-of-type(2n + 5),*/


/** note: using 'of :not' we are independent of how many dimensions are used to label the rows.
 The selector only depends on the size of the last dimension --> nth-child */
.lastDimSize2.hidden :where(thead tr:last-of-type, tbody tr) *:nth-child(2n + 2 of :not([scope^=row], [class^="rowdim"])) {
    display: none;
    background-color: darkseagreen;
}

/* 95% */
.ci-hidden :where(thead tr:last-of-type, tbody tr) *:nth-child(6n + 2 of :not([scope^=row], [class^="rowdim"])),
/* 68% */
.ci-hidden :where(thead tr:last-of-type, tbody tr) *:nth-child(6n + 3 of :not([scope^=row], [class^="rowdim"])) {
    display: none;
}